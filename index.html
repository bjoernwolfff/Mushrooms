<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pilz Identifier ‚Äî Mehrere Open-Source Modelle</title>
<!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
<style>
  /* (Kompakter Stil ‚Äî du kannst dein bestehendes CSS wieder verwenden) */
  body{font-family:Segoe UI,system-ui,Arial;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px}
  .container{max-width:980px;margin:0 auto;background:rgba(255,255,255,.95);backdrop-filter:blur(8px);border-radius:14px;padding:22px}
  h1{margin-bottom:6px} .note{color:#c0392b;font-weight:700;margin-bottom:12px}
  .controls{display:flex;gap:16px;flex-wrap:wrap;align-items:center;margin-bottom:18px}
  .controls > div{background:#f7f9fc;padding:10px;border-radius:10px}
  .upload-area{border:3px dashed #3498db;border-radius:12px;padding:22px;text-align:center;cursor:pointer;background:linear-gradient(135deg,rgba(52,152,219,0.03),rgba(155,89,182,0.03))}
  .preview{display:flex;gap:12px;flex-wrap:wrap;margin:14px 0}
  .preview img{width:160px;height:120px;object-fit:cover;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.12)}
  .btn{background:#3498db;color:#fff;padding:10px 16px;border-radius:8px;border:none;cursor:pointer}
  .results{margin-top:18px}
  .image-block{display:flex;gap:14px;align-items:flex-start;margin-bottom:20px;padding:12px;background:#fff;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.05)}
  .model-column{min-width:220px;border-left:1px solid #eee;padding-left:12px}
  .model-header{font-weight:700;margin-bottom:6px}
  .prediction{background:#f3f6fb;padding:8px;border-radius:8px;margin-bottom:8px}
  .spinner{border:4px solid #f3f3f3;border-top:4px solid #3498db;border-radius:50%;width:36px;height:36px;animation:spin 1s linear infinite;margin:auto}
  @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
  .error{color:#e74c3c;font-weight:700}
  .small{font-size:0.9rem;color:#666}
  table{width:100%;border-collapse:collapse}
  td,th{padding:6px;border-bottom:1px solid #eee}
</style>
</head>
<body>
  <div class="container">
    <h1>üçÑ Pilz Identifier ‚Äî Modellvergleich (Open-Source)</h1>
    <p class="small">W√§hle Land und mehrere Modelle aus ‚Äî die Seite f√ºhrt mehrere Modelle parallel aus und zeigt Top-Predictions pro Bild.</p>
    <div class="note">‚ö†Ô∏è Niemals ausschlie√üliches Modell-Output f√ºr Verzehrentscheidungen nutzen!</div>

    <div class="controls">
      <div>
        <label for="countrySelect"><strong>üåç Land:</strong></label><br>
        <select id="countrySelect">
          <option value="DE">Deutschland</option>
          <option value="AT">√ñsterreich</option>
          <option value="CH">Schweiz</option>
          <option value="INT" selected>International</option>
        </select>
      </div>

      <div>
        <strong>ü§ñ Modelle:</strong><br>
        <label><input type="checkbox" name="models" value="mobilenet" checked> MobileNet V2 (TF Hub)</label><br>
        <label><input type="checkbox" name="models" value="mushroomlite"> MushroomLite (TFJS - placeholder)</label><br>
        <label><input type="checkbox" name="models" value="efficientnet"> EfficientNet Mushroom (TFJS - placeholder)</label>
      </div>

      <div>
        <strong>üîß Benutzerdefiniert:</strong><br>
        <input id="customModelUrl" placeholder="model.json URL (optional)" style="width:300px;padding:6px;border-radius:6px">
        <div class="small">Wenn du eine URL einf√ºgst, wird sie als zus√§tzliches Modell geladen (ebenfalls ausw√§hlbar).</div>
      </div>
    </div>

    <div class="upload-area" id="uploadArea">
      <div style="font-size:28px">üì∑</div>
      <div>Klicke oder ziehe Bilder hierher (JPG/PNG/WEBP) ‚Äî mehrere m√∂glich</div>
      <input type="file" id="fileInput" accept="image/*" multiple style="display:none">
    </div>

    <div class="preview" id="previewContainer"></div>

    <div style="margin-top:12px">
      <button class="btn" id="analyzeBtn">üîç Analysiere ausgew√§hlte Modelle</button>
      <button class="btn" id="reloadModelsBtn" style="background:#2ecc71;margin-left:8px">üîÅ (Neu)Modelle laden</button>
    </div>

    <div id="status" style="margin-top:12px"></div>

    <div class="results" id="results"></div>
  </div>

<script>
/*
  Hinweise:
  - MobileNet V2 (TF Hub) ist als GraphModel geladen.
  - F√ºr spezialisierte Pilzmodelle musst du echte TFJS model.json-URLs einsetzen.
  - Labels: Wenn neben model.json eine labels.json liegt (gleicher Ordner), versucht der Code diese zu laden.
  - Country filtering: Da keine Datenbank vorhanden ist, gibt es hier nur eine UI-Auswahl.
    Du kannst pro Modell optional eine labels->country mapping JSON bereitstellen und den Code erweitern.
*/

// ------ Modellkonfiguration (√§ndere URLs falls du echte Modelle findest) ------
const MODEL_REGISTRY = {
  mobilenet: {
    id: 'mobilenet',
    title: 'MobileNet V2 (ImageNet) ‚Äî TF Hub',
    // TF Hub graph model URL (works with tf.loadGraphModel)
    url: 'https://tfhub.dev/google/tfjs-model/imagenet/mobilenet_v2_100_224/classification/3/default/1',
    type: 'tfhub', // graph model from TF Hub
    labelsUrl: null // ImageNet-Labels not bundled here; optional to provide a labels.json URL
  },
  mushroomlite: {
    id: 'mushroomlite',
    title: 'MushroomLite (placeholder)',
    // PLATZHALTER: ersetze mit echtem TFJS model.json (zB GitHub oder HuggingFace)
    url: 'https://raw.githubusercontent.com/yourname/mushroom-lite/main/model/model.json',
    type: 'tfjs',
    labelsUrl: 'https://raw.githubusercontent.com/yourname/mushroom-lite/main/model/labels.json' // optional
  },
  efficientnet: {
    id: 'efficientnet',
    title: 'EfficientNet Mushroom (placeholder)',
    url: 'https://huggingface.co/yourname/mushroom-efficientnet/resolve/main/model.json',
    type: 'tfjs',
    labelsUrl: 'https://huggingface.co/yourname/mushroom-efficientnet/resolve/main/labels.json'
  }
};
// ---------------------------------------------------------------------------

let selectedFiles = [];
const previewContainer = document.getElementById('previewContainer');
const fileInput = document.getElementById('fileInput');
const uploadArea = document.getElementById('uploadArea');
const analyzeBtn = document.getElementById('analyzeBtn');
const statusDiv = document.getElementById('status');
const resultsDiv = document.getElementById('results');
const reloadModelsBtn = document.getElementById('reloadModelsBtn');

let loadedModels = {}; // { id: { model: tf.Model, labels: [...] } }

function setStatus(html) { statusDiv.innerHTML = html; }

// Drag & drop + file select
uploadArea.addEventListener('click', () => fileInput.click());
uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.style.borderColor='#27ae60'; });
uploadArea.addEventListener('dragleave', e => { e.preventDefault(); uploadArea.style.borderColor=''; });
uploadArea.addEventListener('drop', e => {
  e.preventDefault(); uploadArea.style.borderColor='';
  const files = Array.from(e.dataTransfer.files || []);
  handleFiles(files);
});
fileInput.addEventListener('change', e => handleFiles(Array.from(e.target.files)));

function handleFiles(files) {
  files.forEach(file => {
    if (!file.type.startsWith('image/')) return;
    selectedFiles.push(file);
    const reader = new FileReader();
    reader.onload = ev => {
      const img = document.createElement('img');
      img.src = ev.target.result;
      previewContainer.appendChild(img);
    };
    reader.readAsDataURL(file);
  });
  setStatus(`<span class="small">${selectedFiles.length} Bild(er) bereit.</span>`);
}

// ---- Model Loading & Helpers ----
async function loadModelEntry(entry) {
  // entry: { id, url, type, labelsUrl? }
  try {
    setStatus(`Lade Modell: ${entry.title} ...`);
    let model = null;
    if (entry.type === 'tfhub') {
      // TF Hub graph model: use tf.loadGraphModel with fromTFHub prefix true
      // tf.loadGraphModel accepts the TF Hub URL directly if using the special path; we'll use loadGraphModel
      model = await tf.loadGraphModel(entry.url, {fromTFHub: true});
    } else {
      // general TFJS model.json (layers or graph) - try loadGraphModel first, fallback to loadLayersModel
      try {
        model = await tf.loadGraphModel(entry.url);
      } catch (err) {
        // fallback
        model = await tf.loadLayersModel(entry.url);
      }
    }

    // Try to load labels if available (labels.json next to model.json)
    let labels = null;
    if (entry.labelsUrl) {
      try {
        const resp = await fetch(entry.labelsUrl);
        if (resp.ok) labels = await resp.json();
      } catch (err) { /* ignore */ }
    } else {
      // Try to guess labels.json by swapping model.json name (if it's a model.json URL)
      try {
        const guess = guessLabelsUrl(entry.url);
        if (guess) {
          const r = await fetch(guess);
          if (r.ok) labels = await r.json();
        }
      } catch (e) {}
    }

    loadedModels[entry.id] = { model, labels, title: entry.title, url: entry.url };
    setStatus(`Modell geladen: ${entry.title}`);
  } catch (err) {
    console.error('Model load error', entry.id, err);
    loadedModels[entry.id] = { error: true, title: entry.title, url: entry.url, message: (err && err.message) || String(err) };
    setStatus(`<span class="error">Fehler beim Laden von ${entry.title}: ${err && err.message}</span>`);
  }
}

function guessLabelsUrl(modelUrl) {
  // If modelUrl ends with model.json, replace with labels.json
  try {
    const u = new URL(modelUrl);
    if (u.pathname.endsWith('model.json')) {
      u.pathname = u.pathname.replace(/model\.json$/, 'labels.json');
      return u.toString();
    }
  } catch(e){}
  return null;
}

async function loadSelectedModels() {
  setStatus('Starte Modell-Ladevorgang...');
  // clear previous
  loadedModels = {};
  const checkboxes = Array.from(document.querySelectorAll('input[name="models"]:checked'));
  const customUrl = document.getElementById('customModelUrl').value.trim();
  // Build list
  const toLoad = [];
  for (const cb of checkboxes) {
    const id = cb.value;
    if (id === 'mobilenet') toLoad.push(MODEL_REGISTRY.mobilenet);
    else if (id === 'mushroomlite') toLoad.push(MODEL_REGISTRY.mushroomlite);
    else if (id === 'efficientnet') toLoad.push(MODEL_REGISTRY.efficientnet);
  }
  if (customUrl) {
    toLoad.push({ id: 'custom', title: 'Benutzerdefiniertes Modell', url: customUrl, type: 'tfjs' });
  }
  if (toLoad.length === 0) {
    setStatus('<span class="error">Bitte mindestens ein Modell ausw√§hlen.</span>');
    return;
  }
  // Load in parallel but report individually
  await Promise.all(toLoad.map(entry => loadModelEntry(entry)));
  setStatus('Modell-Ladevorgang abgeschlossen.');
}

// Preprocessing: resize to 224x224, normalize to [0,1]
function preprocessImageElement(img, size=224) {
  return tf.tidy(() => {
    let t = tf.browser.fromPixels(img).toFloat();
    // If image has alpha channel, drop it
    if (t.shape[2] === 4) {
      t = t.slice([0,0,0],[t.shape[0],t.shape[1],3]);
    }
    // resize
    const resized = tf.image.resizeBilinear(t, [size, size]);
    const normalized = resized.div(255.0);
    // add batch
    const batched = normalized.expandDims(0);
    return batched;
  });
}

// Run prediction for a loaded model entry. Return topK results [{label, score}] or indices if no labels.
async function predictWithLoadedModel(loaded, imgEl, topK=3) {
  if (!loaded || loaded.error) return { error: loaded && loaded.message ? loaded.message : 'Model not loaded' };
  try {
    // Choose input size heuristically; default 224
    const inputSize = 224;
    const tensor = preprocessImageElement(imgEl, inputSize);
    let logits = null;
    // Many graph models return logits or probabilities
    const model = loaded.model;
    // Determine whether model.predict or model.execute is needed
    let outputTensor;
    try {
      const out = model.predict ? model.predict(tensor) : model.execute ? model.execute(tensor) : null;
      outputTensor = out;
      // If graph model returns array, pick first element
      if (Array.isArray(outputTensor)) outputTensor = outputTensor[0];
    } catch (e) {
      // Try execute with named output
      try { outputTensor = model.execute(tensor); } catch (e2) { throw e2; }
    }
    // Convert to 1D scores
    let scores = await outputTensor.data();
    // free Tensors
    tf.dispose(outputTensor);
    tensor.dispose();

    // Ensure Float32Array
    scores = Array.from(scores);
    // If outputs are logits, apply softmax
    const max = Math.max(...scores);
    const exps = scores.map(s => Math.exp(s - max));
    const sumExps = exps.reduce((a,b)=>a+b,0);
    const probs = exps.map(e=> e / sumExps);

    // get topK indices
    const indices = probs.map((p,i)=>[p,i]).sort((a,b)=>b[0]-a[0]).slice(0, topK);
    const results = indices.map(([p,i]) => {
      return { index: i, score: Math.round(p*10000)/100 }; // score in %
    });

    // Attach labels if available
    if (loaded.labels && Array.isArray(loaded.labels) && loaded.labels.length>0) {
      results.forEach(r => r.label = loaded.labels[r.index] || `#${r.index}`);
    }
    return { results };
  } catch (err) {
    console.error('Prediction error', err);
    return { error: err.message || String(err) };
  }
}

// ---- UI: Analyze ----
analyzeBtn.addEventListener('click', async () => {
  // ensure models loaded
  await loadSelectedModels();

  if (selectedFiles.length === 0) {
    setStatus('<span class="error">Bitte zuerst Bilder hochladen.</span>');
    return;
  }

  resultsDiv.innerHTML = '';
  setStatus('Starte Analyse der Bilder...');

  const country = document.getElementById('countrySelect').value;
  const checkboxes = Array.from(document.querySelectorAll('input[name="models"]:checked'));
  // Build selected model IDs including custom if provided
  let modelIds = checkboxes.map(cb => cb.value);
  const customUrl = document.getElementById('customModelUrl').value.trim();
  if (customUrl) modelIds.push('custom');

  // For each selected file, create an image element and run all models
  for (const file of selectedFiles) {
    const reader = new FileReader();
    await new Promise(resolveFile => {
      reader.onload = async (ev) => {
        const imgEl = new Image();
        imgEl.src = ev.target.result;
        await new Promise(imgLoaded => { imgEl.onload = imgLoaded; });

        // build UI block
        const block = document.createElement('div');
        block.className = 'image-block';

        // left: image preview + meta
        const left = document.createElement('div');
        left.style.minWidth = '220px';
        left.innerHTML = `
          <div style="margin-bottom:8px"><img src="${ev.target.result}" style="max-width:200px; border-radius:8px"></div>
          <div class="small">Datei: ${file.name}</div>
          <div class="small">Land: ${country}</div>
        `;
        block.appendChild(left);

        // right: per-model columns
        const right = document.createElement('div');
        right.style.display = 'flex';
        right.style.gap = '12px';
        right.style.flexWrap = 'wrap';
        right.style.flex = '1';

        // For each model, show spinner -> predictions
        for (const mid of modelIds) {
          const wrapper = document.createElement('div');
          wrapper.className = 'model-column';
          wrapper.style.minWidth = '220px';
          wrapper.innerHTML = `<div class="model-header">${mid}</div><div class="small">Lade Ergebnis...</div><div class="spinner" style="margin-top:8px"></div>`;
          right.appendChild(wrapper);

          // choose loadedModel entry
          let loaded = null;
          if (mid === 'custom') {
            loaded = loadedModels['custom'] || { model: null, labels: null, title: 'Benutzerdefiniertes Modell' };
          } else {
            loaded = loadedModels[mid];
          }

          // run prediction
          (async () => {
            if (!loaded) {
              wrapper.innerHTML = `<div class="model-header">${mid}</div><div class="error">Modell nicht geladen.</div>`;
              return;
            }
            if (loaded.error) {
              wrapper.innerHTML = `<div class="model-header">${loaded.title || mid}</div><div class="error">Fehler: ${loaded.message || 'Ladefehler'}</div>`;
              return;
            }
            const res = await predictWithLoadedModel(loaded, imgEl, 3);
            if (res.error) {
              wrapper.innerHTML = `<div class="model-header">${loaded.title || mid}</div><div class="error">Vorhersagefehler: ${res.error}</div>`;
              return;
            }
            // render results
            let html = `<div class="model-header">${loaded.title || mid}</div>`;
            if (loaded.url) html += `<div class="small">Quelle: <span title="${loaded.url}">${shorten(loaded.url)}</span></div>`;
            html += `<div style="margin-top:8px">`;
            for (const r of res.results) {
              const label = r.label ? escapeHtml(r.label) : `#${r.index}`;
              html += `<div class="prediction"><strong>${label}</strong><div class="small">Confidence: ${r.score}%</div></div>`;
            }
            html += `</div>`;
            wrapper.innerHTML = html;
          })();
        } // end for models

        block.appendChild(right);
        resultsDiv.appendChild(block);
        resolveFile();
      };
      reader.readAsDataURL(file);
    });
  } // end for files

  setStatus('Analyse gestartet ‚Äî Ergebnisse erscheinen unten.');
});

// reload models button
reloadModelsBtn.addEventListener('click', () => loadSelectedModels().then(() => setStatus('Modelle neu geladen.')));

// util
function shorten(url, n=40) { return url.length>n ? url.slice(0,n-3)+'...' : url; }
function escapeHtml(s){ return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// On load: try to pre-load the models checked (optional)
window.addEventListener('load', async () => {
  // Preload checked default models (optional)
  // Comment out if you prefer manual model loading
  await loadSelectedModels();
  setStatus('Bereit. Modelle wurden initial geladen (falls erreichbar).');
});
</script>
</body>
</html>


