<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Magic Mushroom Erkennung</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
<style>
  body { 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
    background: linear-gradient(135deg, #1e3c72, #2a5298); 
    padding: 20px; 
    max-width: 600px; 
    margin: auto; 
    min-height: 100vh;
    color: white;
  }
  h1 { text-align: center; color: #ffffff; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
  #uploadArea { 
    border: 2px dashed #64b5f6; 
    padding: 30px; 
    text-align: center; 
    cursor: pointer; 
    border-radius: 15px; 
    margin-bottom: 20px; 
    background: rgba(255,255,255,0.1); 
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }
  #uploadArea:hover { background: rgba(255,255,255,0.15); border-color: #90caf9; }
  img { max-width: 100%; border-radius: 15px; margin-bottom: 20px; box-shadow: 0 8px 16px rgba(0,0,0,0.3); }
  button { 
    padding: 12px 24px; 
    background: linear-gradient(135deg, #1565c0, #0d47a1); 
    border: none; 
    color: white; 
    border-radius: 8px; 
    cursor: pointer; 
    font-size: 16px;
    font-weight: bold;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
  }
  button:hover:not(:disabled) { 
    background: linear-gradient(135deg, #1976d2, #1565c0); 
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.4);
  }
  button:disabled { 
    background: linear-gradient(135deg, #546e7a, #37474f); 
    cursor: not-allowed; 
    transform: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  #result { font-size: 1.2em; margin-top: 20px; text-align: center; }
  .positive { color: #4caf50; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
  .negative { color: #f44336; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
  .warning { 
    background: rgba(255, 193, 7, 0.2); 
    border: 1px solid #ffc107; 
    padding: 15px; 
    border-radius: 12px; 
    margin-top: 20px; 
    backdrop-filter: blur(10px);
  }
  
  .progress-container { 
    width: 100%; 
    background: rgba(0, 0, 0, 0.3); 
    border-radius: 15px; 
    margin: 15px 0; 
    overflow: hidden;
    display: none;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    height: 35px;
    border: 1px solid rgba(255,255,255,0.1);
  }
  .progress-bar { 
    height: 35px; 
    background: linear-gradient(90deg, #0d47a1, #1565c0, #1976d2, #1565c0, #0d47a1); 
    background-size: 400% 100%;
    border-radius: 15px; 
    transition: width 0.8s ease; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    color: white; 
    font-size: 14px; 
    font-weight: bold;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    width: 0%;
    box-shadow: 0 2px 8px rgba(13, 71, 161, 0.4);
  }
  .loading-animation {
    animation: shimmer 3s infinite, glow 2s infinite alternate;
  }
  @keyframes shimmer {
    0% { background-position: -400% 0; }
    100% { background-position: 400% 0; }
  }
  @keyframes glow {
    0% { box-shadow: 0 2px 8px rgba(13, 71, 161, 0.4); }
    100% { box-shadow: 0 4px 16px rgba(13, 71, 161, 0.8); }
  }
</style>
</head>
<body>

<h1>Magic Mushroom Erkennung</h1>

<div class="warning">
  <strong>‚ö†Wichtiger Hinweis:</strong> Diese App dient nur zu Bildungszwecken. Verlassen Sie sich niemals ausschlie√ülich auf automatische Erkennung bei Pilzen. Konsultieren Sie immer Experten oder verl√§ssliche Quellen, da falsche Identifikation gef√§hrlich sein kann.
</div>

<div id="uploadArea">Klicke oder ziehe ein Bild hierher</div>
<input type="file" id="fileInput" accept="image/*" style="display:none" />

<div class="progress-container" id="modelProgress">
  <div class="progress-bar loading-animation" id="modelProgressBar" style="width: 10%;">Lade Modell... 10%</div>
</div>

<div class="progress-container" id="predictionProgress">
  <div class="progress-bar" id="predictionProgressBar">Analysiere Bild... 0%</div>
</div>

<img id="preview" src="" alt="" style="display:none" />
<button id="predictBtn" disabled>Erkennen</button>

<div id="result"></div>

<script>
  const uploadArea = document.getElementById('uploadArea');
  const fileInput = document.getElementById('fileInput');
  const preview = document.getElementById('preview');
  const predictBtn = document.getElementById('predictBtn');
  const resultDiv = document.getElementById('result');
  const modelProgress = document.getElementById('modelProgress');
  const modelProgressBar = document.getElementById('modelProgressBar');
  const predictionProgress = document.getElementById('predictionProgress');
  const predictionProgressBar = document.getElementById('predictionProgressBar');

  function showModelProgress() {
    modelProgress.style.display = 'block';
    if (!modelProgressBar.classList.contains('loading-animation')) {
      modelProgressBar.classList.add('loading-animation');
    }
  }

  function updateModelProgress(percent, text) {
    modelProgressBar.style.width = percent + '%';
    modelProgressBar.textContent = text || `Lade Modell... ${percent}%`;
    console.log(`Modell-Fortschritt: ${percent}% - ${text}`);
  }

  function hideModelProgress() {
    setTimeout(() => {
      modelProgress.style.display = 'none';
      modelProgressBar.classList.remove('loading-animation');
    }, 1500);
  }

  function showPredictionProgress() {
    predictionProgress.style.display = 'block';
    predictionProgressBar.style.width = '0%';
    predictionProgressBar.classList.add('loading-animation');
  }

  function updatePredictionProgress(percent, text) {
    predictionProgressBar.style.width = percent + '%';
    predictionProgressBar.textContent = text || `Analysiere Bild... ${percent}%`;
  }

  function hidePredictionProgress() {
    setTimeout(() => {
      predictionProgress.style.display = 'none';
      predictionProgressBar.classList.remove('loading-animation');
    }, 1000);
  }

  // Erweiterte Mock-Vorhersage mit realistischeren Mushroom-Erkennungen
  function createAdvancedMockModel() {
    return {
      predict: () => ({
        data: async () => {
          // Erstelle 1000 Klassen wie ImageNet
          const scores = new Float32Array(1000);
          
          // F√ºlle mit sehr niedrigen Zufallswerten
          for (let i = 0; i < 1000; i++) {
            scores[i] = Math.random() * 0.02;
          }
          
          // Definiere Pilz-relevante Indizes mit realistischen Namen
          const mushroomClasses = [
            { index: 945, name: "mushroom", weight: 0.4 },
            { index: 990, name: "agaric", weight: 0.35 },
            { index: 995, name: "bolete", weight: 0.3 },
            { index: 991, name: "gyromitra", weight: 0.25 },
            { index: 992, name: "stinkhorn", weight: 0.2 },
            { index: 993, name: "earthstar", weight: 0.15 },
            { index: 994, name: "hen-of-the-woods", weight: 0.1 }
          ];
          
          // Nicht-Pilz Klassen f√ºr Variation
          const nonMushroomClasses = [
            { index: 281, name: "tabby_cat", weight: 0.4 },
            { index: 207, name: "golden_retriever", weight: 0.35 },
            { index: 948, name: "orange", weight: 0.3 },
            { index: 950, name: "lemon", weight: 0.25 },
            { index: 671, name: "mouse", weight: 0.2 }
          ];
          
          // Zuf√§llig entscheiden ob es ein Pilz ist (60% Chance)
          const isMushroom = Math.random() > 0.4;
          
          if (isMushroom) {
            // W√§hle 2-3 Pilzklassen
            const selectedMushrooms = mushroomClasses
              .sort(() => 0.5 - Math.random())
              .slice(0, Math.floor(Math.random() * 3) + 2);
            
            selectedMushrooms.forEach(mushroom => {
              scores[mushroom.index] = mushroom.weight + Math.random() * 0.3;
            });
            
            // F√ºge ein paar niedrigere Nicht-Pilz Scores hinzu
            const selectedNonMushrooms = nonMushroomClasses
              .sort(() => 0.5 - Math.random())
              .slice(0, 2);
            
            selectedNonMushrooms.forEach(item => {
              scores[item.index] = Math.random() * 0.15;
            });
            
            console.log('Mock: Pilz erkannt -', selectedMushrooms.map(m => m.name));
          } else {
            // Keine Pilze, nur andere Objekte
            const selectedNonMushrooms = nonMushroomClasses
              .sort(() => 0.5 - Math.random())
              .slice(0, Math.floor(Math.random() * 3) + 2);
            
            selectedNonMushrooms.forEach(item => {
              scores[item.index] = item.weight + Math.random() * 0.2;
            });
            
            console.log('Mock: Kein Pilz erkannt -', selectedNonMushrooms.map(i => i.name));
          }
          
          return scores;
        },
        dispose: () => {}
      })
    };
  }

  let model;
  let imgElement;

  const MUSHROOM_LABELS = [
    "agaric", "bolete", "gyromitra", "stinkhorn", "earthstar",
    "coral_fungus", "hen-of-the-woods", "mushroom"
  ];

  // Erweiterte ImageNet Klassen
  const IMAGENET_CLASSES = {
    0: "tench", 1: "goldfish", 2: "great_white_shark", 207: "golden_retriever",
    281: "tabby_cat", 945: "mushroom", 948: "orange", 950: "lemon",
    989: "coral_fungus", 990: "agaric", 991: "gyromitra", 992: "stinkhorn",
    993: "earthstar", 994: "hen-of-the-woods", 995: "bolete"
  };

  uploadArea.addEventListener('click', () => fileInput.click());
  uploadArea.addEventListener('dragover', e => {
    e.preventDefault();
    uploadArea.style.backgroundColor = "#eaf3fc";
  });
  uploadArea.addEventListener('dragleave', e => {
    e.preventDefault();
    uploadArea.style.backgroundColor = "#f9fbfd";
  });
  uploadArea.addEventListener('drop', e => {
    e.preventDefault();
    uploadArea.style.backgroundColor = "#f9fbfd";
    handleFiles(e.dataTransfer.files);
  });

  fileInput.addEventListener('change', e => handleFiles(e.target.files));

  function handleFiles(files) {
    if (!files.length) return;
    const file = files[0];
    if (!file.type.startsWith('image/')) {
      alert('Bitte nur Bilder hochladen.');
      return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
      preview.src = e.target.result;
      preview.style.display = 'block';
      predictBtn.disabled = false;
      imgElement = new Image();
      imgElement.src = e.target.result;
      imgElement.onload = () => {
        resultDiv.textContent = '';
      };
    };
    reader.readAsDataURL(file);
  }

  async function loadModel() {
    showModelProgress();
    
    try {
      updateModelProgress(20, "Verbinde mit TensorFlow Hub...");
      await new Promise(resolve => setTimeout(resolve, 800));
      
      // Versuche aktualisierte, funktionsf√§hige Modell-URLs
      const modelUrls = [
        // MobileNet v2 von offiziellen TensorFlow.js Modellen
        'https://tfhub.dev/tensorflow/tfjs-model/mobilenet_v2_100_224/classification/3/default/1',
        // Backup: MobileNet v1
        'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json'
      ];
      
      let modelLoaded = false;
      
      for (let i = 0; i < modelUrls.length && !modelLoaded; i++) {
        try {
          updateModelProgress(40 + i * 25, `Lade Modell ${i + 1}/2...`);
          
          // F√ºr TensorFlow Hub URLs
          if (modelUrls[i].includes('tfhub.dev')) {
            model = await tf.loadGraphModel(modelUrls[i]);
          } else {
            // F√ºr normale JSON Modelle
            model = await tf.loadLayersModel(modelUrls[i]);
          }
          
          modelLoaded = true;
          console.log(`Modell ${i + 1} erfolgreich von ${modelUrls[i]} geladen!`);
          
          updateModelProgress(85, "Teste Modell...");
          
          // Teste das Modell mit einem Dummy-Input
          const dummyInput = tf.zeros([1, 224, 224, 3]);
          const testOutput = model.predict(dummyInput);
          
          if (testOutput && testOutput.shape) {
            console.log('Modell-Test erfolgreich, Output-Shape:', testOutput.shape);
            testOutput.dispose();
          }
          dummyInput.dispose();
          
        } catch (err) {
          console.warn(`Modell ${i + 1} fehlgeschlagen:`, err.message);
          if (i === modelUrls.length - 1) {
            throw new Error('Alle echten Modelle fehlgeschlagen');
          }
        }
      }
      
      if (!modelLoaded) {
        throw new Error('Kein Modell konnte geladen werden');
      }
      
      updateModelProgress(95, "Initialisierung abgeschlossen...");
      await new Promise(resolve => setTimeout(resolve, 500));
      
      updateModelProgress(100, "Modell bereit! ‚úÖ");
      
      setTimeout(() => {
        resultDiv.innerHTML = '<span class="positive">‚úÖ KI-Modell geladen und bereit!</span>';
        hideModelProgress();
      }, 800);
      
    } catch (error) {
      console.error('Fehler beim Laden des echten Modells:', error);
      console.log('Fallback auf erweiterten Mock-Modus...');
      
      updateModelProgress(70, "Lade Fallback-Modell...");
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Erstelle erweiterten Mock
      model = createAdvancedMockModel();
      
      updateModelProgress(100, "Test-Modell bereit ‚ö†Ô∏è");
      
      setTimeout(() => {
        resultDiv.innerHTML = '<span style="color: orange;">‚ö†Ô∏è Demo-Modus aktiv (Netzwerkprobleme)</span>';
        hideModelProgress();
      }, 1000);
    }
  }

  function preprocessImage(img) {
    return tf.tidy(() => {
      let tensor = tf.browser.fromPixels(img).toFloat();
      if (tensor.shape[2] === 4) {
        tensor = tensor.slice([0,0,0], [tensor.shape[0], tensor.shape[1], 3]);
      }
      const resized = tf.image.resizeBilinear(tensor, [224, 224]);
      const normalized = resized.div(255.0);
      return normalized.expandDims(0);
    });
  }

  async function predict() {
    if (!model || !imgElement) {
      resultDiv.innerHTML = '<span class="negative">Modell oder Bild nicht bereit.</span>';
      return;
    }

    try {
      showPredictionProgress();
      updatePredictionProgress(15, "Starte KI-Analyse...");
      await new Promise(resolve => setTimeout(resolve, 400));

      updatePredictionProgress(35, "Bereite Bild vor...");
      
      let predictions, scores;
      
      // Check if it's our mock model
      if (typeof model.predict === 'function' && !model.predict.toString().includes('native code')) {
        // Mock model
        updatePredictionProgress(55, "Verwende Demo-Algorithmus...");
        await new Promise(resolve => setTimeout(resolve, 600));
        
        predictions = model.predict();
        scores = await predictions.data();
        
      } else {
        // Real TensorFlow model
        updatePredictionProgress(45, "Verarbeite Bilddaten...");
        const inputTensor = preprocessImage(imgElement);
        
        updatePredictionProgress(65, "KI-Analyse l√§uft...");
        await new Promise(resolve => setTimeout(resolve, 800));
        
        predictions = model.predict(inputTensor);
        scores = await predictions.data();
        
        inputTensor.dispose();
      }

      updatePredictionProgress(85, "Verarbeite Ergebnisse...");
      await new Promise(resolve => setTimeout(resolve, 400));

      // Analysiere Top 10 Vorhersagen f√ºr bessere Ergebnisse
      const topPredictions = Array.from(scores)
        .map((score, index) => ({ score, index }))
        .sort((a, b) => b.score - a.score)
        .slice(0, 10);

      let resultText = '<div style="text-align: left;">';
      let mushroomPredictions = [];
      let otherPredictions = [];
      
      topPredictions.forEach(pred => {
        const className = IMAGENET_CLASSES[pred.index] || `Klasse ${pred.index}`;
        const confidence = (pred.score * 100).toFixed(1);
        
        if (MUSHROOM_LABELS.includes(className)) {
          mushroomPredictions.push({ className, confidence, score: pred.score });
        } else if (otherPredictions.length < 3) {
          otherPredictions.push({ className, confidence, score: pred.score });
        }
      });

      updatePredictionProgress(95, "Erstelle Bericht...");

      if (mushroomPredictions.length > 0) {
        const bestMushroom = mushroomPredictions[0];
        resultText = '<div class="positive">üçÑ Pilz erkannt!</div><br>';
        
        resultText += '<strong>Pilz-Erkennungen:</strong><br>';
        mushroomPredictions.forEach(mushroom => {
          resultText += `<div class="positive">‚Ä¢ ${mushroom.className} (${mushroom.confidence}% Vertrauen)</div>`;
        });
        
        if (otherPredictions.length > 0) {
          resultText += '<br><strong>Alternative Erkennungen:</strong><br>';
          otherPredictions.forEach(other => {
            resultText += `<div>‚Ä¢ ${other.className} (${other.confidence}%)</div>`;
          });
        }
        
        resultText += '<br><div class="warning" style="font-size: 0.9em; margin-top: 15px;">';
        resultText += '<strong>‚ö†Ô∏è Wichtiger Sicherheitshinweis:</strong><br>';
        resultText += 'Diese KI-Erkennung ist nicht 100% zuverl√§ssig! Niemals unbekannte Pilze konsumieren. ';
        resultText += 'Konsultieren Sie immer einen Pilz-Experten oder Mykologen zur finalen Bestimmung.';
        resultText += '</div>';
        
      } else {
        resultText = '<div class="negative">‚ùå Kein Pilz erkannt</div><br>';
        resultText += '<strong>Erkannte Objekte:</strong><br>';
        otherPredictions.slice(0, 5).forEach((pred, i) => {
          resultText += `<div>${i + 1}. ${pred.className} (${pred.confidence}%)</div>`;
        });
        
        resultText += '<br><div style="font-size: 0.9em; color: #ccc;">';
        resultText += 'Tipp: F√ºr beste Ergebnisse verwenden Sie ein klares Foto des gesamten Pilzes mit Stiel und Hut.';
        resultText += '</div>';
      }

      resultText += '</div>';

      // Cleanup
      if (predictions && predictions.dispose) {
        predictions.dispose();
      }

      updatePredictionProgress(100, "Analyse abgeschlossen! ‚úÖ");
      
      setTimeout(() => {
        resultDiv.innerHTML = resultText;
        hidePredictionProgress();
      }, 600);

    } catch (error) {
      console.error('Fehler bei der Vorhersage:', error);
      updatePredictionProgress(100, "‚ùå Fehler aufgetreten");
      
      setTimeout(() => {
        resultDiv.innerHTML = '<span class="negative">‚ùå Analysefehler. Bitte versuchen Sie es mit einem anderen Bild.</span>';
        hidePredictionProgress();
      }, 1000);
    }
  }

  predictBtn.addEventListener('click', predict);

  // Starte Modell-Loading automatisch
  window.addEventListener('load', () => {
    setTimeout(loadModel, 1000);
  });
</script>

</body>
</html>
