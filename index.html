<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Magic Mushroom Erkennung</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js" onload="loadModel()"></script>
<style>
  body { font-family: Arial, sans-serif; background: #eef2f3; padding: 20px; max-width: 600px; margin: auto; }
  h1 { text-align: center; }
  #uploadArea { border: 2px dashed #3498db; padding: 30px; text-align: center; cursor: pointer; border-radius: 10px; margin-bottom: 20px; background: #f9fbfd; }
  #uploadArea:hover { background: #eaf3fc; }
  img { max-width: 100%; border-radius: 10px; margin-bottom: 20px; }
  button { padding: 10px 20px; background: #3498db; border: none; color: white; border-radius: 6px; cursor: pointer; }
  button:disabled { background: #9ec9f5; cursor: not-allowed; }
  #result { font-size: 1.2em; margin-top: 20px; text-align: center; }
  .positive { color: #27ae60; font-weight: bold; }
  .negative { color: #e74c3c; font-weight: bold; }
  .warning { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 8px; margin-top: 20px; }
  
  /* Ladebalken Styles */
  .progress-container { 
    width: 100%; 
    background-color: #e9ecef; 
    border-radius: 10px; 
    margin: 15px 0; 
    overflow: hidden;
    display: none;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    height: 30px;
  }
  .progress-bar { 
    height: 30px; 
    background: linear-gradient(90deg, #3498db, #2980b9, #3498db); 
    background-size: 200% 100%;
    border-radius: 10px; 
    transition: width 0.5s ease; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    color: white; 
    font-size: 14px; 
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    width: 0%;
  }
  .loading-animation {
    animation: shimmer 2s infinite, pulse 1.5s infinite;
  }
  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }
  @keyframes pulse {
    0% { opacity: 0.8; }
    50% { opacity: 1; }
    100% { opacity: 0.8; }
  }
</style>
</head>
<body>

<h1>Magic Mushroom Erkennung üçÑ</h1>

<div class="warning">
  <strong>‚ö†Ô∏è Wichtiger Hinweis:</strong> Diese App dient nur zu Bildungszwecken. Verlassen Sie sich niemals ausschlie√ülich auf automatische Erkennung bei Pilzen. Konsultieren Sie immer Experten oder verl√§ssliche Quellen, da falsche Identifikation gef√§hrlich sein kann.
</div>

<div id="uploadArea">Klicke oder ziehe ein Bild hierher</div>
<input type="file" id="fileInput" accept="image/*" style="display:none" />

<!-- Ladebalken f√ºr Modell -->
<div class="progress-container" id="modelProgress" style="display: block;">
  <div class="progress-bar loading-animation" id="modelProgressBar" style="width: 10%;">Lade Modell... 10%</div>
</div>

<!-- Ladebalken f√ºr Vorhersage -->
<div class="progress-container" id="predictionProgress">
  <div class="progress-bar" id="predictionProgressBar">Analysiere Bild... 0%</div>
</div>

<img id="preview" src="" alt="" style="display:none" />
<button id="predictBtn" disabled>Erkennen</button>

<div id="result"></div>

<script>
  const uploadArea = document.getElementById('uploadArea');
  const fileInput = document.getElementById('fileInput');
  const preview = document.getElementById('preview');
  const predictBtn = document.getElementById('predictBtn');
  const resultDiv = document.getElementById('result');
  const modelProgress = document.getElementById('modelProgress');
  const modelProgressBar = document.getElementById('modelProgressBar');
  const predictionProgress = document.getElementById('predictionProgress');
  const predictionProgressBar = document.getElementById('predictionProgressBar');

  // Ladebalken-Funktionen
  function showModelProgress() {
    modelProgress.style.display = 'block';
    if (!modelProgressBar.classList.contains('loading-animation')) {
      modelProgressBar.classList.add('loading-animation');
    }
    console.log('Zeige Modell-Ladebalken');
  }

  function updateModelProgress(percent, text) {
    modelProgressBar.style.width = percent + '%';
    modelProgressBar.textContent = text || `Lade Modell... ${percent}%`;
    console.log(`Modell-Fortschritt: ${percent}% - ${text}`);
  }

  function hideModelProgress() {
    setTimeout(() => {
      modelProgress.style.display = 'none';
      modelProgressBar.classList.remove('loading-animation');
      console.log('Verstecke Modell-Ladebalken');
    }, 1500); // L√§nger sichtbar lassen
  }

  function showPredictionProgress() {
    predictionProgress.style.display = 'block';
    predictionProgressBar.style.width = '0%';
    predictionProgressBar.classList.add('loading-animation');
    console.log('Zeige Vorhersage-Ladebalken');
  }

  function updatePredictionProgress(percent, text) {
    predictionProgressBar.style.width = percent + '%';
    predictionProgressBar.textContent = text || `Analysiere Bild... ${percent}%`;
    console.log(`Vorhersage-Fortschritt: ${percent}% - ${text}`);
  }

  function hidePredictionProgress() {
    setTimeout(() => {
      predictionProgress.style.display = 'none';
      predictionProgressBar.classList.remove('loading-animation');
      console.log('Verstecke Vorhersage-Ladebalken');
    }, 1000);
  }

  // Verbessertes Mock-Modell f√ºr Tests
  function mockPredict() {
    return {
      data: async () => {
        // Simuliere realistischere Vorhersagen
        const scores = new Float32Array(1000);
        
        // F√ºlle mit niedrigen Zufallswerten
        for (let i = 0; i < 1000; i++) {
          scores[i] = Math.random() * 0.05; // Sehr niedrige Basis-Scores
        }
        
        // Simuliere h√∂here Scores f√ºr verschiedene Objekte
        const highScoreIndices = [
          { index: 945, name: "mushroom", baseScore: 0.4 },
          { index: 990, name: "agaric", baseScore: 0.3 },
          { index: 995, name: "bolete", baseScore: 0.2 },
          { index: 991, name: "gyromitra", baseScore: 0.15 },
          { index: 281, name: "tabby_cat", baseScore: 0.25 }, // F√ºr nicht-Pilz Bilder
          { index: 207, name: "golden_retriever", baseScore: 0.35 },
          { index: 948, name: "orange", baseScore: 0.2 }
        ];
        
        // W√§hle zuf√§llig 2-3 hohe Scores aus
        const selectedIndices = highScoreIndices
          .sort(() => 0.5 - Math.random())
          .slice(0, Math.floor(Math.random() * 3) + 2);
        
        selectedIndices.forEach(item => {
          scores[item.index] = item.baseScore + Math.random() * 0.3;
        });
        
        console.log('Mock-Vorhersage generiert:', selectedIndices.map(i => i.name));
        return scores;
      },
      dispose: () => {}
    };
  }

  let model;
  let imgElement;

  // Labels aus ImageNet, die wir als potentielle Pilze interpretieren
  const MUSHROOM_LABELS = [
    "agaric",         // Schirmpilze
    "bolete",         // Steinpilz-√§hnlich
    "gyromitra",      // Morchelartige
    "stinkhorn",      // Stinkmorchel
    "earthstar",      // Erdstern
    "coral_fungus",   // Korallenpilze
    "hen-of-the-woods", // Klapperschwamm
    "mushroom"        // allgemeiner Pilz
  ];

  // ImageNet Klassen (verk√ºrzt f√ºr die wichtigsten)
  const IMAGENET_CLASSES = {
    0:"tench",1:"goldfish",2:"great_white_shark",3:"tiger_shark",4:"hammerhead",
    5:"electric_ray",6:"stingray",7:"cock",8:"hen",9:"ostrich",
    945:"mushroom",989:"coral_fungus",990:"agaric",991:"gyromitra",
    992:"stinkhorn",993:"earthstar",994:"hen-of-the-woods",995:"bolete"
  };

  uploadArea.addEventListener('click', () => fileInput.click());

  uploadArea.addEventListener('dragover', e => {
    e.preventDefault();
    uploadArea.style.backgroundColor = "#eaf3fc";
  });

  uploadArea.addEventListener('dragleave', e => {
    e.preventDefault();
    uploadArea.style.backgroundColor = "#f9fbfd";
  });

  uploadArea.addEventListener('drop', e => {
    e.preventDefault();
    uploadArea.style.backgroundColor = "#f9fbfd";
    handleFiles(e.dataTransfer.files);
  });

  fileInput.addEventListener('change', e => handleFiles(e.target.files));

  function handleFiles(files) {
    if (!files.length) return;
    const file = files[0];
    if (!file.type.startsWith('image/')) {
      alert('Bitte nur Bilder hochladen.');
      return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
      preview.src = e.target.result;
      preview.style.display = 'block';
      predictBtn.disabled = false;
      imgElement = new Image();
      imgElement.src = e.target.result;
      imgElement.onload = () => {
        resultDiv.textContent = '';
      };
    };
    reader.readAsDataURL(file);
  }

  async function loadModel() {
    // Ladebalken ist bereits sichtbar, aktualisiere nur den Fortschritt
    try {
      updateModelProgress(20, "Verbinde mit Server...");
      await new Promise(resolve => setTimeout(resolve, 500));
      
      updateModelProgress(40, "Lade Modell-Dateien...");
      await new Promise(resolve => setTimeout(resolve, 300));
      
      console.log('Versuche Modell zu laden...');
      
      // Versuche verschiedene Modell-URLs
      let modelLoaded = false;
      const modelUrls = [
        'https://tfhub.dev/google/imagenet/mobilenet_v2_100_224/classification/5/default/1',
        'https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_0.25_224/model.json'
      ];
      
      for (let i = 0; i < modelUrls.length && !modelLoaded; i++) {
        try {
          updateModelProgress(50 + i * 20, `Versuche Modell ${i + 1}...`);
          if (i === 0) {
            model = await tf.loadGraphModel(modelUrls[i]);
          } else {
            model = await tf.loadLayersModel(modelUrls[i]);
          }
          modelLoaded = true;
          console.log(`Modell ${i + 1} erfolgreich geladen!`);
        } catch (err) {
          console.log(`Modell ${i + 1} fehlgeschlagen:`, err.message);
        }
      }
      
      if (!modelLoaded) {
        throw new Error('Alle Modell-URLs fehlgeschlagen');
      }
      
      updateModelProgress(90, "Initialisiere Modell...");
      await new Promise(resolve => setTimeout(resolve, 500));
      
      updateModelProgress(100, "Modell bereit! ‚úÖ");
      
      setTimeout(() => {
        resultDiv.textContent = "‚úÖ Modell geladen. Bitte Bild hochladen.";
        hideModelProgress();
      }, 800);
      
    } catch (error) {
      console.error('Fehler beim Laden des Modells:', error);
      updateModelProgress(70, "Fehler - lade Fallback...");
      await new Promise(resolve => setTimeout(resolve, 800));
      
      updateModelProgress(100, "Test-Modell bereit ‚ö†Ô∏è");
      
      setTimeout(() => {
        resultDiv.innerHTML = '<span style="color: orange;">‚ö†Ô∏è Verwende Test-Modell (Netzwerk-Problem)</span>';
        hideModelProgress();
      }, 1000);
      
      // Fallback: Mock-Modell f√ºr Tests
      console.log('Verwende Mock-Modell f√ºr Tests...');
      model = { predict: mockPredict };
    }
  }

  // Event-Listener f√ºr den Predict-Button
  predictBtn.addEventListener('click', predict);

  function preprocessImage(img) {
    return tf.tidy(() => {
      let tensor = tf.browser.fromPixels(img).toFloat();
      if (tensor.shape[2] === 4) {
        tensor = tensor.slice([0,0,0],[tensor.shape[0], tensor.shape[1], 3]);
      }
      const resized = tf.image.resizeBilinear(tensor, [224, 224]);
      const normalized = resized.div(255);
      const batched = normalized.expandDims(0);
      return batched;
    });
  }

  async function predict() {
    console.log('Predict button clicked!');
    console.log('Model loaded:', !!model);
    console.log('Image loaded:', !!imgElement);
    
    if (!model) {
      // Zeige den Modell-Ladebalken wenn Modell nicht geladen
      modelProgress.style.display = 'block';
      modelProgressBar.classList.add('loading-animation');
      updateModelProgress(20, "Modell wird noch geladen...");
      return;
    }
    
    if (!imgElement) {
      resultDiv.innerHTML = '<span class="negative">Kein Bild geladen. Bitte Bild hochladen.</span>';
      return;
    }
    
    try {
      showPredictionProgress();
      await new Promise(resolve => setTimeout(resolve, 300));
      
      updatePredictionProgress(20, "Bereite Bild vor...");
      await new Promise(resolve => setTimeout(resolve, 500));
      
      let predictions;
      if (typeof model.predict === 'function') {
        updatePredictionProgress(40, "Analysiere Bilddaten...");
        await new Promise(resolve => setTimeout(resolve, 400));
        
        // Echtes TensorFlow Modell oder Mock
        if (model.predict === mockPredict) {
          updatePredictionProgress(60, "Verwende Test-Algorithmus...");
          await new Promise(resolve => setTimeout(resolve, 800));
          predictions = model.predict();
        } else {
          const inputTensor = preprocessImage(imgElement);
          updatePredictionProgress(70, "F√ºhre KI-Analyse durch...");
          await new Promise(resolve => setTimeout(resolve, 600));
          predictions = model.predict(inputTensor);
          inputTensor.dispose();
        }
      } else {
        throw new Error('Ung√ºltiges Modell');
      }
      
      updatePredictionProgress(85, "Verarbeite Ergebnisse...");
      await new Promise(resolve => setTimeout(resolve, 400));
      
      const scores = await predictions.data();
      predictions.dispose && predictions.dispose();

      updatePredictionProgress(95, "Erstelle Ausgabe...");
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Finde die Top 5 Vorhersagen
      const topPredictions = Array.from(scores)
        .map((score, index) => ({ score, index }))
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);
      
      let resultText = '<div style="text-align: left;">';
      let foundMushroom = false;
      
      topPredictions.forEach((pred, i) => {
        const className = IMAGENET_CLASSES[pred.index] || `Klasse ${pred.index}`;
        const confidence = (pred.score * 100).toFixed(1);
        
        if (MUSHROOM_LABELS.includes(className)) {
          foundMushroom = true;
          resultText += `<div class="positive">üçÑ ${className} (${confidence}% Vertrauen)</div>`;
        } else {
          resultText += `<div>${i + 1}. ${className} (${confidence}%)</div>`;
        }
      });
      
      if (foundMushroom) {
        resultText = '<div class="positive">üçÑ Pilz erkannt!</div><br>' + resultText;
        resultText += '<br><div class="warning" style="font-size: 0.9em; margin-top: 10px;"><strong>Achtung:</strong> Diese Erkennung ist nicht 100% zuverl√§ssig. Niemals unbekannte Pilze konsumieren!</div>';
      } else {
        resultText = '<div class="negative">‚ùå Kein Pilz erkannt</div><br>' + resultText;
      }
      
      resultText += '</div>';
      
      updatePredictionProgress(100, "Fertig! ‚úÖ");
      setTimeout(() => {
        resultDiv.innerHTML = resultText;
        hidePredictionProgress();
      }, 800);
      
    } catch (error) {
      console.error('Fehler bei der Vorhersage:', error);
      updatePredictionProgress(100, "‚ùå Fehler aufgetreten");
      setTimeout(() => {
        resultDiv.innerHTML = '<span class="negative">Fehler bei der Erkennung. Bitte versuchen Sie es erneut.</span>';
        hidePredictionProgress();
      }, 1500);
    }
  }

  // Modell wird automatisch geladen wenn TensorFlow.js bereit ist (siehe onload im script tag)
</script>

</body>
</html>
