<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pilz Identifier ‚Äî Mehrere Open-Source Modelle</title>
<!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
<style>
  body{font-family:Segoe UI,system-ui,Arial;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px}
  .container{max-width:980px;margin:0 auto;background:rgba(255,255,255,.95);backdrop-filter:blur(8px);border-radius:14px;padding:22px}
  h1{margin-bottom:6px} .note{color:#c0392b;font-weight:700;margin-bottom:12px}
  .controls{display:flex;gap:16px;flex-wrap:wrap;align-items:center;margin-bottom:18px}
  .controls > div{background:#f7f9fc;padding:10px;border-radius:10px}
  .upload-area{border:3px dashed #3498db;border-radius:12px;padding:22px;text-align:center;cursor:pointer;background:linear-gradient(135deg,rgba(52,152,219,0.03),rgba(155,89,182,0.03))}
  .preview{display:flex;gap:12px;flex-wrap:wrap;margin:14px 0}
  .preview img{width:160px;height:120px;object-fit:cover;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,.12)}
  .btn{background:#3498db;color:#fff;padding:10px 16px;border-radius:8px;border:none;cursor:pointer}
  .results{margin-top:18px}
  .image-block{display:flex;gap:14px;align-items:flex-start;margin-bottom:20px;padding:12px;background:#fff;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.05)}
  .model-column{min-width:220px;border-left:1px solid #eee;padding-left:12px}
  .model-header{font-weight:700;margin-bottom:6px}
  .prediction{background:#f3f6fb;padding:8px;border-radius:8px;margin-bottom:8px}
  .spinner{border:4px solid #f3f3f3;border-top:4px solid #3498db;border-radius:50%;width:36px;height:36px;animation:spin 1s linear infinite;margin:auto}
  @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
  .error{color:#e74c3c;font-weight:700}
  .small{font-size:0.9rem;color:#666}
  table{width:100%;border-collapse:collapse}
  td,th{padding:6px;border-bottom:1px solid #eee}

  /* Smartphone-Optimierung */
  @media (max-width: 600px) {
    body { padding: 10px; }
    .container { padding: 14px; }
    .controls { flex-direction: column; gap: 10px; }
    .controls > div { width: 100%; }
    .preview img { width: 100%; height: auto; }
    .image-block { flex-direction: column; }
    .image-block > div { width: 100%; }
    .model-column {
      min-width: unset;
      border-left: none;
      border-top: 1px solid #eee;
      padding-left: 0;
      padding-top: 8px;
    }
    .model-header { font-size: 1rem; }
  }
</style>
</head>
<body>
  <div class="container">
    <h1>üçÑ Pilz Identifier ‚Äî Modellvergleich (Open-Source)</h1>
    <p class="small">W√§hle Land und mehrere Modelle aus ‚Äî die Seite f√ºhrt mehrere Modelle parallel aus und zeigt Top-Predictions pro Bild.</p>
    <div class="note">‚ö†Ô∏è Niemals ausschlie√üliches Modell-Output f√ºr Verzehrentscheidungen nutzen!</div>

    <div class="controls">
      <div>
        <label for="countrySelect"><strong>üåç Land:</strong></label><br>
        <select id="countrySelect">
          <option value="DE">Deutschland</option>
          <option value="AT">√ñsterreich</option>
          <option value="CH">Schweiz</option>
          <option value="INT" selected>International</option>
        </select>
      </div>

      <div>
        <strong>ü§ñ Modelle:</strong><br>
        <label><input type="checkbox" name="models" value="mobilenet" checked> MobileNet V2 (TF Hub)</label><br>
        <label><input type="checkbox" name="models" value="mushroomlite"> MushroomLite (TFJS - placeholder)</label><br>
        <label><input type="checkbox" name="models" value="efficientnet"> EfficientNet Mushroom (TFJS - placeholder)</label>
      </div>

      <div>
        <strong>üîß Benutzerdefiniert:</strong><br>
        <input id="customModelUrl" placeholder="model.json URL (optional)" style="width:300px;padding:6px;border-radius:6px">
        <div class="small">Wenn du eine URL einf√ºgst, wird sie als zus√§tzliches Modell geladen (ebenfalls ausw√§hlbar).</div>
      </div>
    </div>

    <div class="upload-area" id="uploadArea">
      <div style="font-size:28px">üì∑</div>
      <div>Klicke oder ziehe Bilder hierher (JPG/PNG/WEBP) ‚Äî mehrere m√∂glich</div>
      <input type="file" id="fileInput" accept="image/*" multiple style="display:none">
    </div>

    <div class="preview" id="previewContainer"></div>

    <div style="margin-top:12px">
      <button class="btn" id="analyzeBtn">üîç Analysiere ausgew√§hlte Modelle</button>
      <button class="btn" id="reloadModelsBtn" style="background:#2ecc71;margin-left:8px">üîÅ (Neu)Modelle laden</button>
    </div>

    <div id="status" style="margin-top:12px"></div>

    <div class="results" id="results"></div>
  </div>

<script>
const MODEL_REGISTRY = {
  mobilenet: {
    id: 'mobilenet',
    title: 'MobileNet V2 (ImageNet) ‚Äî TF Hub',
    url: 'https://tfhub.dev/google/tfjs-model/imagenet/mobilenet_v2_100_224/classification/3/default/1',
    type: 'tfhub',
    labelsUrl: 'https://bjoernwolfff.github.io/Mushrooms/labels.json'
  },
  mushroomlite: {
    id: 'mushroomlite',
    title: 'MushroomLite (Pilze)',
    url: 'https://raw.githubusercontent.com/yourname/mushroom-lite/main/model/model.json',
    type: 'tfjs',
    labelsUrl: 'https://bjoernwolfff.github.io/Mushrooms/labels.json'
  },
  efficientnet: {
    id: 'efficientnet',
    title: 'EfficientNet Mushroom',
    url: 'https://huggingface.co/yourname/mushroom-efficientnet/resolve/main/model.json',
    type: 'tfjs',
    labelsUrl: 'https://bjoernwolfff.github.io/Mushrooms/labels.json'
  }
};

let selectedFiles = [];
const previewContainer = document.getElementById('previewContainer');
const fileInput = document.getElementById('fileInput');
const uploadArea = document.getElementById('uploadArea');
const analyzeBtn = document.getElementById('analyzeBtn');
const statusDiv = document.getElementById('status');
const resultsDiv = document.getElementById('results');
const reloadModelsBtn = document.getElementById('reloadModelsBtn');

let loadedModels = {}; // { id: { model: tf.Model, labels: [...] } }

function setStatus(html) { statusDiv.innerHTML = html; }

uploadArea.addEventListener('click', () => fileInput.click());
uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.style.borderColor='#27ae60'; });
uploadArea.addEventListener('dragleave', e => { e.preventDefault(); uploadArea.style.borderColor=''; });
uploadArea.addEventListener('drop', e => {
  e.preventDefault(); uploadArea.style.borderColor='';
  const files = Array.from(e.dataTransfer.files || []);
  handleFiles(files);
});
fileInput.addEventListener('change', e => handleFiles(Array.from(e.target.files)));

function handleFiles(files) {
  files.forEach(file => {
    if (!file.type.startsWith('image/')) return;
    selectedFiles.push(file);
    const reader = new FileReader();
    reader.onload = ev => {
      const img = document.createElement('img');
      img.src = ev.target.result;
      previewContainer.appendChild(img);
    };
    reader.readAsDataURL(file);
  });
  setStatus(`<span class="small">${selectedFiles.length} Bild(er) bereit.</span>`);
}

async function loadModelEntry(entry) {
  try {
    setStatus(`Lade Modell: ${entry.title} ...`);
    let model = null;
    if (entry.type === 'tfhub') {
      model = await tf.loadGraphModel(entry.url, {fromTFHub: true});
    } else {
      try {
        model = await tf.loadGraphModel(entry.url);
      } catch (err) {
        model = await tf.loadLayersModel(entry.url);
      }
    }
    let labels = null;
    if (entry.labelsUrl) {
      try {
        const resp = await fetch(entry.labelsUrl);
        if (resp.ok) labels = await resp.json();
      } catch (err) { }
    }
    loadedModels[entry.id] = { model, labels, title: entry.title, url: entry.url };
    setStatus(`Modell geladen: ${entry.title}`);
  } catch (err) {
    console.error('Model load error', entry.id, err);
    loadedModels[entry.id] = { error: true, title: entry.title, url: entry.url, message: (err && err.message) || String(err) };
    setStatus(`<span class="error">Fehler beim Laden von ${entry.title}: ${err && err.message}</span>`);
  }
}

async function loadSelectedModels() {
  setStatus('Starte Modell-Ladevorgang...');
  loadedModels = {};
  const checkboxes = Array.from(document.querySelectorAll('input[name="models"]:checked'));
  const customUrl = document.getElementById('customModelUrl').value.trim();
  const toLoad = [];
  for (const cb of checkboxes) {
    const id = cb.value;
    if (MODEL_REGISTRY[id]) toLoad.push(MODEL_REGISTRY[id]);
  }
  if (customUrl) {
    toLoad.push({ id: 'custom', title: 'Benutzerdefiniertes Modell', url: customUrl, type: 'tfjs', labelsUrl: 'https://bjoernwolfff.github.io/Mushrooms/labels.json' });
  }
  if (toLoad.length === 0) {
    setStatus('<span class="error">Bitte mindestens ein Modell ausw√§hlen.</span>');
    return;
  }
  await Promise.all(toLoad.map(entry => loadModelEntry(entry)));
  setStatus('Modell-Ladevorgang abgeschlossen.');
}

function preprocessImageElement(img, size=224) {
  return tf.tidy(() => {
    let t = tf.browser.fromPixels(img).toFloat();
    if (t.shape[2] === 4) {
      t = t.slice([0,0,0],[t.shape[0],t.shape[1],3]);
    }
    const resized = tf.image.resizeBilinear(t, [size, size]);
    const normalized = resized.div(255.0);
    const batched = normalized.expandDims(0);
    return batched;
  });
}

async function predictWithLoadedModel(loaded, imgEl, topK=3) {
  if (!loaded || loaded.error) return { error: loaded && loaded.message ? loaded.message : 'Model not loaded' };
  try {
    const tensor = preprocessImageElement(imgEl, 224);
    let outputTensor;
    const out = loaded.model.predict ? loaded.model.predict(tensor) : loaded.model.execute(tensor);
    outputTensor = Array.isArray(out) ? out[0] : out;
    let scores = await outputTensor.data();
    tf.dispose(outputTensor);
    tensor.dispose();
    scores = Array.from(scores);
    const max = Math.max(...scores);
    const exps = scores.map(s => Math.exp(s - max));
    const sumExps = exps.reduce((a,b)=>a+b,0);
    const probs = exps.map(e=> e / sumExps);
    const indices = probs.map((p,i)=>[p,i]).sort((a,b)=>b[0]-a[0]).slice(0, topK);
    const results = indices.map(([p,i]) => ({ index: i, score: Math.round(p*10000)/100, label: loaded.labels ? loaded.labels[i] : `#${i}` }));
    return { results };
  } catch (err) {
    console.error('Prediction error', err);
    return { error: err.message || String(err) };
  }
}

analyzeBtn.addEventListener('click', async () => {
  await loadSelectedModels();
  if (selectedFiles.length === 0) {
    setStatus('<span class="error">Bitte zuerst Bilder hochladen.</span>');
    return;
  }
  resultsDiv.innerHTML = '';
  setStatus('Starte Analyse der Bilder...');
  const country = document.getElementById('countrySelect').value;
  const checkboxes = Array.from(document.querySelectorAll('input[name="models"]:checked'));
  let modelIds = checkboxes.map(cb => cb.value);
  const customUrl = document.getElementById('customModelUrl').value.trim();
  if (customUrl) modelIds.push('custom');
  for (const file of selectedFiles) {
    const reader = new FileReader();
    await new Promise(resolveFile => {
      reader.onload = async (ev) => {
        const imgEl = new Image();
        imgEl.src = ev.target.result;
        await new Promise(imgLoaded => { imgEl.onload = imgLoaded; });
        const block = document.createElement('div');
        block.className = 'image-block';
        const left = document.createElement('div');
        left.style.minWidth = '220px';
        left.innerHTML = `<div style="margin-bottom:8px"><img src="${ev.target.result}" style="max-width:200px; border-radius:8px"></div>
                          <div class="small">Datei: ${file.name}</div>
                          <div class="small">Land: ${country}</div>`;
        block.appendChild(left);
        const right = document.createElement('div');
        right.style.display = 'flex';
        right.style.gap = '12px';
        right.style.flexWrap = 'wrap';
        right.style.flex = '1';
        for (const mid of modelIds) {
          const wrapper = document.createElement('div');
          wrapper.className = 'model-column';
          wrapper.style.minWidth = '220px';
          wrapper.innerHTML = `<div class="model-header">${mid}</div><div class="small">Lade Ergebnis...</div><div class="spinner" style="margin-top:8px"></div>`;
          right.appendChild(wrapper);
          let loaded = mid === 'custom' ? loadedModels['custom'] : loadedModels[mid];
          (async () => {
            if (!loaded) {
              wrapper.innerHTML = `<div class="model-header">${mid}</div><div class="error">Modell nicht geladen.</div>`;
              return;
            }
            if (loaded.error) {
              wrapper.innerHTML = `<div class="model-header">${loaded.title || mid}</div><div class="error">Fehler: ${loaded.message || 'Ladefehler'}</div>`;
              return;
            }
            const res = await predictWithLoadedModel(loaded, imgEl, 3);
            if (res.error) {
              wrapper.innerHTML = `<div class="model-header">${loaded.title || mid}</div><div class="error">Vorhersagefehler: ${res.error}</div>`;
              return;
            }
            let html = `<div class="model-header">${loaded.title || mid}</div>`;
            if (loaded.url) html += `<div class="small">Quelle: <span title="${loaded.url}">${shorten(loaded.url)}</span></div>`;
            html += `<div style="margin-top:8px">`;
            for (const r of res.results) {
              const label = r.label ? escapeHtml(r.label) : `#${r.index}`;
              html += `<div class="prediction"><strong>${label}</strong><div class="small">Confidence: ${r.score}%</div></div>`;
            }
            html += `</div>`;
            wrapper.innerHTML = html;
          })();
        }
        block.appendChild(right);
        resultsDiv.appendChild(block);
        resolveFile();
      };
      reader.readAsDataURL(file);
    });
  }
  setStatus('Analyse gestartet ‚Äî Ergebnisse erscheinen unten.');
});

reloadModelsBtn.addEventListener('click', () => loadSelectedModels().then(() => setStatus('Modelle neu geladen.')));

function shorten(url, n=40) { return url.length>n ? url.slice(0,n-3)+'...' : url; }
function escapeHtml(s){ return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

window.addEventListener('load', async () => {
  await loadSelectedModels();
  setStatus('Bereit. Modelle wurden initial geladen (falls erreichbar).');
});
</script>
</body>
</html>
