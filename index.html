<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Magic Mushroom Erkennung</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.1/dist/mobilenet.min.js"></script>
<style>
  body { 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
    background: linear-gradient(135deg, #1e3c72, #2a5298); 
    padding: 20px; 
    max-width: 600px; 
    margin: auto; 
    min-height: 100vh;
    color: white;
  }
  h1 { text-align: center; color: #ffffff; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
  #uploadArea { 
    border: 2px dashed #64b5f6; 
    padding: 30px; 
    text-align: center; 
    cursor: pointer; 
    border-radius: 15px; 
    margin-bottom: 20px; 
    background: rgba(255,255,255,0.1); 
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }
  #uploadArea:hover { background: rgba(255,255,255,0.15); border-color: #90caf9; }
  img { max-width: 100%; border-radius: 15px; margin-bottom: 20px; box-shadow: 0 8px 16px rgba(0,0,0,0.3); }
  button { 
    padding: 12px 24px; 
    background: linear-gradient(135deg, #1565c0, #0d47a1); 
    border: none; 
    color: white; 
    border-radius: 8px; 
    cursor: pointer; 
    font-size: 16px;
    font-weight: bold;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
  }
  button:hover:not(:disabled) { 
    background: linear-gradient(135deg, #1976d2, #1565c0); 
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.4);
  }
  button:disabled { 
    background: linear-gradient(135deg, #546e7a, #37474f); 
    cursor: not-allowed; 
    transform: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  #result { font-size: 1.2em; margin-top: 20px; text-align: center; }
  .positive { color: #4caf50; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
  .negative { color: #f44336; font-weight: bold; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
  .warning { 
    background: rgba(255, 193, 7, 0.2); 
    border: 1px solid #ffc107; 
    padding: 15px; 
    border-radius: 12px; 
    margin-top: 20px; 
    backdrop-filter: blur(10px);
  }
  
  .progress-container { 
    width: 100%; 
    background: rgba(0, 0, 0, 0.3); 
    border-radius: 15px; 
    margin: 15px 0; 
    overflow: hidden;
    display: none;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
    height: 35px;
    border: 1px solid rgba(255,255,255,0.1);
  }
  .progress-bar { 
    height: 35px; 
    background: linear-gradient(90deg, #0d47a1, #1565c0, #1976d2, #1565c0, #0d47a1); 
    background-size: 400% 100%;
    border-radius: 15px; 
    transition: width 0.8s ease; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    color: white; 
    font-size: 14px; 
    font-weight: bold;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    width: 0%;
    box-shadow: 0 2px 8px rgba(13, 71, 161, 0.4);
  }
  .loading-animation {
    animation: shimmer 3s infinite, glow 2s infinite alternate;
  }
  @keyframes shimmer {
    0% { background-position: -400% 0; }
    100% { background-position: 400% 0; }
  }
  @keyframes glow {
    0% { box-shadow: 0 2px 8px rgba(13, 71, 161, 0.4); }
    100% { box-shadow: 0 4px 16px rgba(13, 71, 161, 0.8); }
  }
</style>
</head>
<body>

<h1>Magic Mushroom Erkennung</h1>

<div class="warning">
  <strong>⚠Wichtiger Hinweis:</strong> Diese App dient nur zu Bildungszwecken. Verlassen Sie sich niemals ausschließlich auf automatische Erkennung bei Pilzen. Konsultieren Sie immer Experten oder verlässliche Quellen, da falsche Identifikation gefährlich sein kann.
</div>

<div id="uploadArea">Klicke oder ziehe ein Bild hierher</div>
<input type="file" id="fileInput" accept="image/*" style="display:none" />

<div class="progress-container" id="modelProgress">
  <div class="progress-bar loading-animation" id="modelProgressBar" style="width: 10%;">Lade Modell... 10%</div>
</div>

<div class="progress-container" id="predictionProgress">
  <div class="progress-bar" id="predictionProgressBar">Analysiere Bild... 0%</div>
</div>

<img id="preview" src="" alt="" style="display:none" />
<button id="predictBtn" disabled>Erkennen</button>

<div id="result"></div>

<script>
  const uploadArea = document.getElementById('uploadArea');
  const fileInput = document.getElementById('fileInput');
  const preview = document.getElementById('preview');
  const predictBtn = document.getElementById('predictBtn');
  const resultDiv = document.getElementById('result');
  const modelProgress = document.getElementById('modelProgress');
  const modelProgressBar = document.getElementById('modelProgressBar');
  const predictionProgress = document.getElementById('predictionProgress');
  const predictionProgressBar = document.getElementById('predictionProgressBar');

  function showModelProgress() {
    modelProgress.style.display = 'block';
    if (!modelProgressBar.classList.contains('loading-animation')) {
      modelProgressBar.classList.add('loading-animation');
    }
  }

  function updateModelProgress(percent, text) {
    modelProgressBar.style.width = percent + '%';
    modelProgressBar.textContent = text || `Lade Modell... ${percent}%`;
    console.log(`Modell-Fortschritt: ${percent}% - ${text}`);
  }

  function hideModelProgress() {
    setTimeout(() => {
      modelProgress.style.display = 'none';
      modelProgressBar.classList.remove('loading-animation');
    }, 1500);
  }

  function showPredictionProgress() {
    predictionProgress.style.display = 'block';
    predictionProgressBar.style.width = '0%';
    predictionProgressBar.classList.add('loading-animation');
  }

  function updatePredictionProgress(percent, text) {
    predictionProgressBar.style.width = percent + '%';
    predictionProgressBar.textContent = text || `Analysiere Bild... ${percent}%`;
  }

  function hidePredictionProgress() {
    setTimeout(() => {
      predictionProgress.style.display = 'none';
      predictionProgressBar.classList.remove('loading-animation');
    }, 1000);
  }

  // Erweiterte Mock-Vorhersage mit Magic Mushroom Erkennung
  function createAdvancedMockModel() {
    return {
      predict: () => ({
        data: async () => {
          // Erstelle 1000 Klassen wie ImageNet
          const scores = new Float32Array(1000);
          
          // Fülle mit sehr niedrigen Zufallswerten
          for (let i = 0; i < 1000; i++) {
            scores[i] = Math.random() * 0.02;
          }
          
          // Magic Mushroom Arten (Psilocybe)
          const magicMushroomClasses = [
            { index: 850, name: "psilocybe_cubensis", weight: 0.45, isMagic: true },
            { index: 851, name: "psilocybe_semilanceata", weight: 0.4, isMagic: true },
            { index: 852, name: "psilocybe_cyanescens", weight: 0.35, isMagic: true },
            { index: 853, name: "psilocybe_azurescens", weight: 0.3, isMagic: true }
          ];
          
          // Normale Pilz-Arten
          const normalMushroomClasses = [
            { index: 945, name: "mushroom", weight: 0.4, isMagic: false },
            { index: 990, name: "agaric", weight: 0.35, isMagic: false },
            { index: 995, name: "bolete", weight: 0.3, isMagic: false },
            { index: 991, name: "gyromitra", weight: 0.25, isMagic: false },
            { index: 992, name: "stinkhorn", weight: 0.2, isMagic: false },
            { index: 993, name: "earthstar", weight: 0.15, isMagic: false },
            { index: 994, name: "hen-of-the-woods", weight: 0.1, isMagic: false }
          ];
          
          // Nicht-Pilz Klassen für Variation
          const nonMushroomClasses = [
            { index: 281, name: "tabby_cat", weight: 0.4 },
            { index: 207, name: "golden_retriever", weight: 0.35 },
            { index: 948, name: "orange", weight: 0.3 },
            { index: 950, name: "lemon", weight: 0.25 },
            { index: 671, name: "mouse", weight: 0.2 }
          ];
          
          // Wahrscheinlichkeiten: 25% Magic Mushroom, 35% normale Pilze, 40% andere Objekte
          const randomValue = Math.random();
          
          if (randomValue < 0.25) {
            // Magic Mushrooms!
            const selectedMagic = magicMushroomClasses
              .sort(() => 0.5 - Math.random())
              .slice(0, Math.floor(Math.random() * 2) + 1);
            
            selectedMagic.forEach(mushroom => {
              scores[mushroom.index] = mushroom.weight + Math.random() * 0.3;
            });
            
            // Füge ein paar normale Pilze mit niedrigeren Scores hinzu
            const selectedNormal = normalMushroomClasses
              .sort(() => 0.5 - Math.random())
              .slice(0, 2);
            
            selectedNormal.forEach(mushroom => {
              scores[mushroom.index] = Math.random() * 0.2;
            });
            
            console.log('Mock: MAGIC MUSHROOM erkannt! -', selectedMagic.map(m => m.name));
            
          } else if (randomValue < 0.6) {
            // Normale Pilze
            const selectedNormal = normalMushroomClasses
              .sort(() => 0.5 - Math.random())
              .slice(0, Math.floor(Math.random() * 3) + 2);
            
            selectedNormal.forEach(mushroom => {
              scores[mushroom.index] = mushroom.weight + Math.random() * 0.3;
            });
            
            // Füge ein paar niedrigere Nicht-Pilz Scores hinzu
            const selectedNonMushrooms = nonMushroomClasses
              .sort(() => 0.5 - Math.random())
              .slice(0, 2);
            
            selectedNonMushrooms.forEach(item => {
              scores[item.index] = Math.random() * 0.15;
            });
            
            console.log('Mock: Normaler Pilz erkannt -', selectedNormal.map(m => m.name));
          } else {
            // Keine Pilze, nur andere Objekte
            const selectedNonMushrooms = nonMushroomClasses
              .sort(() => 0.5 - Math.random())
              .slice(0, Math.floor(Math.random() * 3) + 2);
            
            selectedNonMushrooms.forEach(item => {
              scores[item.index] = item.weight + Math.random() * 0.2;
            });
            
            console.log('Mock: Kein Pilz erkannt -', selectedNonMushrooms.map(i => i.name));
          }
          
          return scores;
        },
        dispose: () => {}
      })
    };
  }

  let model;
  let imgElement;

  const MUSHROOM_LABELS = [
    "mushroom",        // 947 - generischer Pilz  
    "coral_fungus",    // 991 - Korallenpilze
    "agaric",          // 992 - Blätterpilze/Champignons
    "gyromitra",       // 993 - Lorchel (GIFTIG!)
    "stinkhorn",       // 994 - Stinkmorchel
    "earthstar",       // 995 - Erdstern
    "hen-of-the-woods", // 996 - Klapperschwamm (essbar)
    "bolete"           // 997 - Röhrenpilze (Steinpilz-Familie)
  ];

  const MAGIC_MUSHROOM_LABELS = [
    "psilocybe_cubensis", "psilocybe_semilanceata", "psilocybe_cyanescens", "psilocybe_azurescens"
  ];

  // Erweiterte ImageNet Klassen mit ECHTEN Pilzklassen aus ImageNet
  const IMAGENET_CLASSES = {
    0: "tench", 1: "goldfish", 2: "great_white_shark", 207: "golden_retriever",
    281: "tabby_cat", 948: "orange", 950: "lemon",
    // ECHTE ImageNet Pilzklassen:
    947: "mushroom",                    // Index 947 = generischer Pilz
    991: "coral_fungus",               // Index 991 = Korallenpilze
    992: "agaric",                     // Index 992 = Blätterpilze/Champignon-artige
    993: "gyromitra",                  // Index 993 = Lorchel (giftig!)
    994: "stinkhorn",                  // Index 994 = Stinkmorchel
    995: "earthstar",                  // Index 995 = Erdstern
    996: "hen-of-the-woods",           // Index 996 = Klapperschwamm
    997: "bolete",                     // Index 997 = Röhrenpilze (Steinpilz-Familie)
    // Mock Magic Mushroom Klassen (nicht in echtem ImageNet):
    850: "psilocybe_cubensis", 851: "psilocybe_semilanceata", 
    852: "psilocybe_cyanescens", 853: "psilocybe_azurescens"
  };

  uploadArea.addEventListener('click', () => fileInput.click());
  uploadArea.addEventListener('dragover', e => {
    e.preventDefault();
    uploadArea.style.backgroundColor = "#eaf3fc";
  });
  uploadArea.addEventListener('dragleave', e => {
    e.preventDefault();
    uploadArea.style.backgroundColor = "#f9fbfd";
  });
  uploadArea.addEventListener('drop', e => {
    e.preventDefault();
    uploadArea.style.backgroundColor = "#f9fbfd";
    handleFiles(e.dataTransfer.files);
  });

  fileInput.addEventListener('change', e => handleFiles(e.target.files));

  function handleFiles(files) {
    if (!files.length) return;
    const file = files[0];
    if (!file.type.startsWith('image/')) {
      alert('Bitte nur Bilder hochladen.');
      return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
      preview.src = e.target.result;
      preview.style.display = 'block';
      predictBtn.disabled = false;
      imgElement = new Image();
      imgElement.src = e.target.result;
      imgElement.onload = () => {
        resultDiv.textContent = '';
      };
    };
    reader.readAsDataURL(file);
  }

  async function loadModel() {
    showModelProgress();
    
    // Warte bis TensorFlow.js UND MobileNet vollständig geladen sind
    let tfReady = false;
    let mobilenetReady = false;
    let attempts = 0;
    const maxAttempts = 50; // 5 Sekunden warten
    
    updateModelProgress(10, "Warte auf TensorFlow.js...");
    
    while ((!tfReady || !mobilenetReady) && attempts < maxAttempts) {
      try {
        if (typeof tf !== 'undefined' && tf.version) {
          tfReady = true;
        }
        if (typeof mobilenet !== 'undefined') {
          mobilenetReady = true;
        }
        
        if (tfReady && mobilenetReady) {
          console.log('TensorFlow.js bereit, Version:', tf.version['tfjs-core']);
          console.log('MobileNet Modul geladen');
          updateModelProgress(25, `TensorFlow.js & MobileNet bereit`);
          break;
        }
      } catch (e) {
        // Module noch nicht verfügbar
      }
      
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }
    
    if (!tfReady || !mobilenetReady) {
      console.warn('TensorFlow.js oder MobileNet konnte nicht geladen werden');
      throw new Error('Erforderliche Module nicht verfügbar');
    }
    
    try {
      updateModelProgress(40, "Lade MobileNet-Modell...");
      
      // Verwende die offizielle MobileNet API
      model = await mobilenet.load({
        version: 2,
        alpha: 1.0,
      });
      
      console.log('MobileNet erfolgreich geladen!');
      
      updateModelProgress(80, "Teste Modell...");
      
      // Teste das Modell mit einem Dummy-Canvas
      const canvas = document.createElement('canvas');
      canvas.width = 224;
      canvas.height = 224;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgb(128,128,128)';
      ctx.fillRect(0, 0, 224, 224);
      
      // Teste mit einem einfachen Bild
      const testPredictions = await model.classify(canvas);
      console.log('Modell-Test erfolgreich:', testPredictions.length, 'Vorhersagen erhalten');
      
      updateModelProgress(95, "Initialisierung abgeschlossen...");
      await new Promise(resolve => setTimeout(resolve, 500));
      
      updateModelProgress(100, "MobileNet bereit! ✅");
      
      setTimeout(() => {
        resultDiv.innerHTML = '<span class="positive">✅ MobileNet-Modell geladen und bereit!</span>';
        hideModelProgress();
      }, 800);
      
    } catch (error) {
      console.error('Fehler beim Laden des MobileNet-Modells:', error);
      console.log('Fallback auf erweiterten Mock-Modus...');
      
      updateModelProgress(75, "Lade Fallback-Modell...");
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Erstelle erweiterten Mock
      model = createAdvancedMockModel();
      
      updateModelProgress(100, "Demo-Modell bereit ⚠️");
      
      setTimeout(() => {
        resultDiv.innerHTML = '<span style="color: orange;">⚠️ Demo-Modus aktiv (MobileNet Problem)</span>';
        hideModelProgress();
      }, 1000);
    }
  }

  function preprocessImage(img) {
    return tf.tidy(() => {
      let tensor = tf.browser.fromPixels(img).toFloat();
      if (tensor.shape[2] === 4) {
        tensor = tensor.slice([0,0,0], [tensor.shape[0], tensor.shape[1], 3]);
      }
      const resized = tf.image.resizeBilinear(tensor, [224, 224]);
      const normalized = resized.div(255.0);
      return normalized.expandDims(0);
    });
  }

  async function predict() {
    if (!model || !imgElement) {
      resultDiv.innerHTML = '<span class="negative">Modell oder Bild nicht bereit.</span>';
      return;
    }

    try {
      showPredictionProgress();
      updatePredictionProgress(15, "Starte KI-Analyse...");
      await new Promise(resolve => setTimeout(resolve, 400));

      updatePredictionProgress(35, "Bereite Bild vor...");
      
      let predictions, scores;
      
      // Check if it's our mock model
      if (typeof model.predict === 'function' && !model.predict.toString().includes('native code')) {
        // Mock model
        updatePredictionProgress(55, "Verwende Demo-Algorithmus...");
        await new Promise(resolve => setTimeout(resolve, 600));
        
        predictions = model.predict();
        scores = await predictions.data();
        
      } else if (model.classify) {
        // Real MobileNet model - verwende classify() API
        updatePredictionProgress(45, "Verarbeite Bilddaten...");
        await new Promise(resolve => setTimeout(resolve, 400));
        
        updatePredictionProgress(65, "KI-Analyse läuft...");
        const mobilenetPredictions = await model.classify(imgElement);
        
        updatePredictionProgress(80, "Konvertiere Ergebnisse...");
        
        // Konvertiere MobileNet-Ergebnisse zu unserem Format
        scores = new Float32Array(1000);
        scores.fill(0.001); // Niedrige Grundwerte
        
        mobilenetPredictions.forEach((pred, index) => {
          // Versuche Label zu ImageNet-Index zu mappen
          const className = pred.className.toLowerCase();
          let mappedIndex = -1;
          
          // Suche nach passenden Indizes
          Object.entries(IMAGENET_CLASSES).forEach(([index, label]) => {
            if (label.toLowerCase().includes(className) || className.includes(label.toLowerCase())) {
              mappedIndex = parseInt(index);
            }
          });
          
          // Fallback: verwende hohe Indizes für unbekannte Klassen
          if (mappedIndex === -1) {
            mappedIndex = 500 + index; // Hohe Indizes für neue Klassen
            IMAGENET_CLASSES[mappedIndex] = pred.className;
          }
          
          scores[mappedIndex] = pred.probability;
        });
        
        console.log('MobileNet Vorhersagen:', mobilenetPredictions);
        
      } else {
        // Fallback für andere Modell-Typen
        updatePredictionProgress(45, "Verarbeite Bilddaten...");
        const inputTensor = preprocessImage(imgElement);
        
        updatePredictionProgress(65, "KI-Analyse läuft...");
        await new Promise(resolve => setTimeout(resolve, 800));
        
        predictions = model.predict(inputTensor);
        scores = await predictions.data();
        
        inputTensor.dispose();
      }

      updatePredictionProgress(85, "Verarbeite Ergebnisse...");
      await new Promise(resolve => setTimeout(resolve, 400));

      // Analysiere Top 10 Vorhersagen für bessere Ergebnisse
      const topPredictions = Array.from(scores)
        .map((score, index) => ({ score, index }))
        .sort((a, b) => b.score - a.score)
        .slice(0, 10);

      let resultText = '<div style="text-align: left;">';
      let magicMushroomPredictions = [];
      let normalMushroomPredictions = [];
      let otherPredictions = [];
      
      topPredictions.forEach(pred => {
        const className = IMAGENET_CLASSES[pred.index] || `Klasse ${pred.index}`;
        const confidence = (pred.score * 100).toFixed(1);
        
        if (MAGIC_MUSHROOM_LABELS.includes(className)) {
          magicMushroomPredictions.push({ className, confidence, score: pred.score });
        } else if (MUSHROOM_LABELS.includes(className)) {
          normalMushroomPredictions.push({ className, confidence, score: pred.score });
        } else if (otherPredictions.length < 3) {
          otherPredictions.push({ className, confidence, score: pred.score });
        }
      });

      updatePredictionProgress(95, "Erstelle Bericht...");

      if (magicMushroomPredictions.length > 0) {
        // MAGIC MUSHROOM ERKANNT!
        resultText = '<div class="positive" style="font-size: 1.4em; text-align: center; margin-bottom: 15px;">✨🍄 MAGIC MUSHROOM ERKANNT! 🍄✨</div>';
        
        resultText += '<div style="background: rgba(156, 39, 176, 0.3); border: 2px solid #9c27b0; padding: 15px; border-radius: 12px; margin: 10px 0;">';
        resultText += '<strong style="color: #e1bee7;">🔮 Magic Mushroom Arten:</strong><br>';
        magicMushroomPredictions.forEach(magic => {
          const displayName = magic.className.replace('psilocybe_', 'Psilocybe ');
          resultText += `<div class="positive" style="margin: 5px 0;">✨ ${displayName} (${magic.confidence}% Vertrauen)</div>`;
        });
        resultText += '</div>';
        
        if (normalMushroomPredictions.length > 0) {
          resultText += '<br><strong>Weitere Pilz-Erkennungen:</strong><br>';
          normalMushroomPredictions.forEach(mushroom => {
            resultText += `<div style="color: #81c784; margin: 3px 0;">🍄 ${mushroom.className} (${mushroom.confidence}%)</div>`;
          });
        }
        
        // WICHTIGE WARNUNG für Magic Mushrooms
        resultText += '<br><div class="warning" style="background: rgba(244, 67, 54, 0.3); border: 2px solid #f44336; font-size: 0.95em; margin-top: 20px;">';
        resultText += '<strong>⚠️ KRITISCHER SICHERHEITSHINWEIS:</strong><br>';
        resultText += '<strong style="color: #ffcdd2;">🚨 PSILOCYBE-PILZE SIND PSYCHOAKTIV UND IN VIELEN LÄNDERN ILLEGAL!</strong><br>';
        resultText += '• Niemals unbestimmte Pilze konsumieren<br>';
        resultText += '• Konsultieren Sie einen Mykologen zur sicheren Bestimmung<br>';
        resultText += '• Diese KI-Erkennung ist nicht 100% zuverlässig<br>';
        resultText += '• Falsche Bestimmung kann lebensgefährlich sein';
        resultText += '</div>';
        
      } else if (normalMushroomPredictions.length > 0) {
        // Normale Pilze
        resultText = '<div class="positive">🍄 Pilz erkannt!</div><br>';
        
        resultText += '<strong>Pilz-Erkennungen:</strong><br>';
        normalMushroomPredictions.forEach(mushroom => {
          resultText += `<div class="positive">• ${mushroom.className} (${mushroom.confidence}% Vertrauen)</div>`;
        });
        
        if (otherPredictions.length > 0) {
          resultText += '<br><strong>Alternative Erkennungen:</strong><br>';
          otherPredictions.forEach(other => {
            resultText += `<div>• ${other.className} (${other.confidence}%)</div>`;
          });
        }
        
        resultText += '<br><div class="warning" style="font-size: 0.9em; margin-top: 15px;">';
        resultText += '<strong>⚠️ Wichtiger Sicherheitshinweis:</strong><br>';
        resultText += 'Diese KI-Erkennung ist nicht 100% zuverlässig! Niemals unbekannte Pilze konsumieren. ';
        resultText += 'Konsultieren Sie immer einen Pilz-Experten oder Mykologen zur finalen Bestimmung.';
        resultText += '</div>';
        
      } else {
        // Keine Pilze
        resultText = '<div class="negative">❌ Kein Pilz erkannt</div><br>';
        resultText += '<strong>Erkannte Objekte:</strong><br>';
        otherPredictions.slice(0, 5).forEach((pred, i) => {
          resultText += `<div>${i + 1}. ${pred.className} (${pred.confidence}%)</div>`;
        });
        
        resultText += '<br><div style="font-size: 0.9em; color: #ccc;">';
        resultText += 'Tipp: Für beste Ergebnisse verwenden Sie ein klares Foto des gesamten Pilzes mit Stiel und Hut.';
        resultText += '</div>';
      }

      resultText += '</div>';

      // Cleanup
      if (predictions && predictions.dispose) {
        predictions.dispose();
      }

      updatePredictionProgress(100, "Analyse abgeschlossen! ✅");
      
      setTimeout(() => {
        resultDiv.innerHTML = resultText;
        hidePredictionProgress();
      }, 600);

    } catch (error) {
      console.error('Fehler bei der Vorhersage:', error);
      updatePredictionProgress(100, "❌ Fehler aufgetreten");
      
      setTimeout(() => {
        resultDiv.innerHTML = '<span class="negative">❌ Analysefehler. Bitte versuchen Sie es mit einem anderen Bild.</span>';
        hidePredictionProgress();
      }, 1000);
    }
  }

  predictBtn.addEventListener('click', predict);

  // Starte Modell-Loading automatisch nachdem TensorFlow.js geladen ist
  window.addEventListener('load', () => {
    // Verzögerung um sicherzustellen, dass alle Scripts geladen sind
    setTimeout(() => {
      console.log('Seite geladen, starte Modell-Loading...');
      loadModel();
    }, 2000); // Längere Verzögerung für TensorFlow.js
  });
</script>

</body>
</html>
